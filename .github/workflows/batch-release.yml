name: Batch Release

on:
  release:
    types: [published]

concurrency:
  group: release
  cancel-in-progress: true

env:
  S3_BUCKET: ${{ vars.S3_BUCKET_NAME }}
  POLICY_HUB_API_URL: ${{ vars.POLICY_HUB_API_URL }}
  AWS_REGION: ${{ vars.AWS_REGION }}
  MAX_PARALLEL: ${{ vars.MAX_PARALLEL || 3 }}

jobs:
  verify-health:
    name: Verify Prerequisites
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github
          sparse-checkout-cone-mode: false
      
      - name: Verify Policy Hub health
        uses: ./.github/actions/verify-policy-hub-health
        with:
          policy-hub-url: ${{ vars.POLICY_HUB_API_URL }}

  detect-versions:
    name: Detect New Policy Versions
    needs: verify-health
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      new-versions: ${{ steps.detect.outputs.new-versions }}
      new-versions-json: ${{ steps.format.outputs.json }}
      version-count: ${{ steps.count.outputs.count }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.release.target_commitish }}

      - name: Get base SHA
        id: get_base
        run: |
          set -euo pipefail  # Exit on error, undefined vars, pipe failures
          
          current_tag="${{ github.event.release.tag_name }}"
          echo "Current release tag: $current_tag"
          
          base_sha=""
          
          # Priority 1: Use last successful release SHA if file exists and is valid
          if [ -f last-successful-release.sha ]; then
            candidate_sha=$(cat last-successful-release.sha | tr -d '\n')
            # Validate SHA and checksum if present
            if git rev-parse --verify "$candidate_sha" >/dev/null 2>&1; then
              # Check for checksum file to detect tampering
              if [ -f last-successful-release.sha.sha256 ]; then
                expected_checksum=$(cat last-successful-release.sha.sha256)
                actual_checksum=$(echo "$candidate_sha" | sha256sum | awk '{print $1}')
                if [ "$expected_checksum" != "$actual_checksum" ]; then
                  echo "‚ö†Ô∏è  Checksum mismatch for last-successful-release.sha, ignoring file"
                  candidate_sha=""
                fi
              fi
              if [ -n "$candidate_sha" ]; then
                base_sha="$candidate_sha"
                echo "‚úÖ Using last successful release SHA: $base_sha"
              fi
            else
              echo "‚ö†Ô∏è  Invalid SHA in last-successful-release.sha ($candidate_sha), ignoring file"
            fi
          fi
          
          # Priority 2: Fallback to latest tag if no valid SHA and tags exist (for migration)
          if [ -z "$base_sha" ]; then
            latest_tag=$(git tag --sort=-version:refname | head -1 || echo "")
            if [ -n "$latest_tag" ] && git rev-parse --verify "$latest_tag" >/dev/null 2>&1; then
              base_sha="$latest_tag"
              echo "‚úÖ Using latest tag as fallback: $base_sha"
            fi
          fi
          
          # Priority 3: Initial commit if still no base
          if [ -z "$base_sha" ]; then
            base_sha=$(git rev-list --max-parents=0 HEAD)
            echo "‚úÖ First release detected, using initial commit: $base_sha"
          fi
          
          # Final validation
          if ! git rev-parse --verify "$base_sha" >/dev/null 2>&1; then
            echo "‚ùå Final base SHA is invalid: $base_sha"
            exit 1
          fi
          
          echo "base_sha=$base_sha" >> $GITHUB_OUTPUT
        shell: bash

      - name: Detect new policy versions
        id: detect
        uses: ./.github/actions/detect-versions
        with:
          base-sha: ${{ steps.get_base.outputs.base_sha }}
          head-sha: ${{ github.sha }}

      - name: Format versions for matrix
        id: format
        run: |
          versions="${{ steps.detect.outputs.new-versions }}"
          json_array="[]"
          if [ -n "$versions" ]; then
            json_array="["
            first=true
            for version_path in $versions; do
              if [ "$first" = true ]; then
                first=false
              else
                json_array+=","
              fi
              policy=$(echo $version_path | cut -d'/' -f1)
              version=$(echo $version_path | cut -d'/' -f2)
              json_array+="{\"policy\":\"$policy\",\"version\":\"$version\"}"
            done
            json_array+="]"
          fi
          echo "json=$json_array" >> $GITHUB_OUTPUT

      - name: Count versions
        id: count
        run: |
          version_count=$(echo "${{ steps.detect.outputs.new-versions }}" | wc -w)
          echo "count=$version_count" >> $GITHUB_OUTPUT

  validate-policies:
    name: Validate Policies
    needs: detect-versions
    if: needs.detect-versions.outputs.version-count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate policies before release
        run: |
          echo "üîç Validating all policies before release using configurable requirements..."
          
          # Make validation script executable
          chmod +x scripts/validate-policy.sh
          
          validation_errors=0
          versions="${{ needs.detect-versions.outputs.new-versions }}"
          
          for version_path in $versions; do
            policy=$(echo $version_path | cut -d'/' -f1)
            version=$(echo $version_path | cut -d'/' -f2)
            
            echo "üìã Pre-release validation for $policy/$version"
            
            if ./scripts/validate-policy.sh "$policy" "$version" 2>&1; then
              echo "‚úÖ Pre-release validation passed for $policy/$version"
            else
              echo "‚ùå Pre-release validation failed for $policy/$version"
              ((validation_errors++))
            fi
          done
          
          if [ $validation_errors -gt 0 ]; then
            echo ""
            echo "üí• Pre-release validation failed with $validation_errors error(s)."
            echo "üìã Release blocked - fix validation issues before publishing"
            exit 1
          else
            echo ""
            echo "üéâ All policies passed pre-release validation!"
            echo "üìã Ready for publishing with configurable requirements verified"
          fi

  publish-policies:
    name: Publish to Production
    needs: [detect-versions, validate-policies]
    if: needs.detect-versions.outputs.version-count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: production
    strategy:
      fail-fast: false
      matrix:
        version-item: ${{ fromJSON(needs.detect-versions.outputs.new-versions-json) }}
      max-parallel: ${{ fromJSON(env.MAX_PARALLEL) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Publish policy version
        id: publish
        uses: ./.github/actions/publish-policy
        with:
          policy: ${{ matrix.version-item.policy }}
          version: ${{ matrix.version-item.version }}
          s3-bucket: ${{ vars.S3_BUCKET_NAME }}
          policy-hub-url: ${{ vars.POLICY_HUB_API_URL }}
          repo-url: ${{ github.server_url }}/${{ github.repository }}
          policy-hub-api-key: ${{ secrets.POLICY_HUB_API_KEY }}

      - name: Report result
        if: always()
        run: |
          if [[ "${{ steps.publish.outputs.success }}" == "true" ]]; then
            echo "‚úÖ Successfully published ${{ matrix.version-item.policy }} ${{ matrix.version-item.version }}"
          else
            echo "‚ùå Failed to publish ${{ matrix.version-item.policy }} ${{ matrix.version-item.version }}"
            exit 1
          fi

  update-success-sha:
    name: Update Success Tracking
    needs: publish-policies
    if: success()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.release.target_commitish }}
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update last successful release SHA
        run: |
          set -euo pipefail
          
          current_sha="${{ github.sha }}"
          file="last-successful-release.sha"
          
          # Check if update is needed
          if [ -f "$file" ] && [ "$(cat $file | tr -d '\n')" = "$current_sha" ]; then
            echo "‚ÑπÔ∏è  SHA file already up-to-date, skipping update"
            exit 0
          fi
          
          # Update the file
          echo "$current_sha" > "$file"
          # Generate checksum for integrity
          echo "$current_sha" | sha256sum | awk '{print $1}' > "${file}.sha256"
          
          # Configure Git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add and commit
          git add "$file" "${file}.sha256"
          git commit -m "chore: update last successful release SHA to $current_sha"
          
          # Push with retry
          max_retries=3
          retry_count=0
          while [ $retry_count -lt $max_retries ]; do
            if git push origin HEAD; then
              echo "‚úÖ Successfully updated last successful release SHA"
              exit 0
            else
              retry_count=$((retry_count + 1))
              echo "‚ö†Ô∏è  Push failed (attempt $retry_count/$max_retries), retrying in 5s..."
              sleep 5
            fi
          done
          
          echo "‚ùå Failed to push SHA update after $max_retries attempts"
          exit 1
        shell: bash