name: Batch Release

on:
  release:
    types: [published]

concurrency:
  group: release
  cancel-in-progress: true

env:
  S3_BUCKET: ${{ vars.S3_BUCKET_NAME }}
  POLICY_HUB_API_URL: ${{ vars.POLICY_HUB_API_URL }}
  AWS_REGION: ${{ vars.AWS_REGION }}
  MAX_PARALLEL: ${{ vars.MAX_PARALLEL || 3 }}

jobs:
  verify-health:
    name: Verify Prerequisites
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github
          sparse-checkout-cone-mode: false
      
      - name: Verify Policy Hub health
        uses: ./.github/actions/verify-policy-hub-health
        with:
          policy-hub-url: ${{ vars.POLICY_HUB_API_URL }}

  detect-versions:
    name: Detect New Policy Versions
    needs: verify-health
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      new-versions: ${{ steps.detect.outputs.new-versions }}
      new-versions-json: ${{ steps.format.outputs.json }}
      version-count: ${{ steps.count.outputs.count }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.release.target_commitish }}

      - name: Get success tracking from main branch
        id: get_tracking
        run: |
          set +e  # Don't exit on error for this step
          
          # Determine default branch (try main, then master)
          default_branch="main"
          if ! git ls-remote --heads origin main | grep -q main; then
            if git ls-remote --heads origin master | grep -q master; then
              default_branch="master"
              echo "‚ÑπÔ∏è  Using 'master' branch (main not found)"
            else
              echo "‚ö†Ô∏è  Neither 'main' nor 'master' branch found"
              echo "has_tracking=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          # Fetch latest from default branch to get the tracking file
          if ! git fetch origin "${default_branch}:refs/remotes/origin/${default_branch}" 2>/dev/null; then
            echo "‚ö†Ô∏è  Failed to fetch ${default_branch} branch"
            echo "has_tracking=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Try to get the file from default branch
          if git show "origin/${default_branch}:last-successful-release.sha" > /tmp/last-successful-release.sha 2>/dev/null; then
            echo "‚úÖ Found tracking file on ${default_branch} branch"
            echo "has_tracking=true" >> $GITHUB_OUTPUT
            
            # Also get checksum if exists
            if git show "origin/${default_branch}:last-successful-release.sha.sha256" > /tmp/last-successful-release.sha.sha256 2>/dev/null; then
              echo "‚úÖ Found tracking checksum"
            fi
          else
            echo "‚ÑπÔ∏è  No tracking file on ${default_branch} branch"
            echo "has_tracking=false" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Get base SHA
        id: get_base
        run: |
          set -euo pipefail  # Exit on error, undefined vars, pipe failures
          
          current_tag="${{ github.event.release.tag_name }}"
          echo "Current release tag: $current_tag"
          
          base_sha=""
          
          # Priority 1: Use last successful release SHA from main branch
          if [ "${{ steps.get_tracking.outputs.has_tracking }}" = "true" ] && [ -f /tmp/last-successful-release.sha ]; then
            candidate_sha=$(cat /tmp/last-successful-release.sha | tr -d '\n')
            echo "üìã Found tracking SHA from main branch: $candidate_sha"
            
            # Validate SHA
            if git rev-parse --verify "$candidate_sha" >/dev/null 2>&1; then
              # Check checksum if present
              if [ -f /tmp/last-successful-release.sha.sha256 ]; then
                expected_checksum=$(cat /tmp/last-successful-release.sha.sha256 | tr -d '\n')
                actual_checksum=$(echo "$candidate_sha" | sha256sum | awk '{print $1}')
                if [ "$expected_checksum" != "$actual_checksum" ]; then
                  echo "‚ö†Ô∏è  Checksum mismatch, ignoring tracking file"
                else
                  base_sha="$candidate_sha"
                  echo "‚úÖ Using last successful release SHA from main branch: $base_sha"
                fi
              else
                base_sha="$candidate_sha"
                echo "‚úÖ Using last successful release SHA from main branch: $base_sha (no checksum)"
              fi
            else
              echo "‚ö†Ô∏è  Invalid SHA in tracking file: $candidate_sha"
            fi
          else
            echo "‚ÑπÔ∏è  No tracking file found on main branch, will use fallback detection"
          fi
          
          # Priority 2: Find last tag with policies (FALLBACK - may include failed releases)
          if [ -z "$base_sha" ]; then
            echo "üîç Falling back to tag-based detection (WARNING: less reliable)..."
            echo "‚ö†Ô∏è  This fallback may include releases where publishing failed"
            
            # Get all tags sorted by version (newest first), excluding current tag
            candidate_tags=$(git tag --sort=-version:refname | grep -v "^${current_tag}$" || echo "")
            
            for tag in $candidate_tags; do
              tag_sha=$(git rev-parse "$tag" 2>/dev/null || echo "")
              if [ -n "$tag_sha" ]; then
                # Check if this tag has any policies by looking for policy directories created at this commit
                policy_count=$(git diff --name-only --diff-filter=A "${tag_sha}^" "$tag_sha" 2>/dev/null | grep '^policies/' | wc -l || echo "0")
                
                if [ "$policy_count" -gt 0 ]; then
                  base_sha="$tag_sha"
                  echo "‚ö†Ô∏è  Using tag with policies as fallback: $tag ($tag_sha)"
                  echo "‚ö†Ô∏è  Note: This tag may have had publishing failures"
                  echo "‚ö†Ô∏è  Recommend: Ensure tracking file exists on main branch for accurate detection"
                  break
                fi
              fi
            done
            
            if [ -z "$base_sha" ]; then
              echo "‚ÑπÔ∏è  No tags with policies found"
            fi
          fi
          
          # Priority 3: Initial commit if still no base
          if [ -z "$base_sha" ]; then
            base_sha=$(git rev-list --max-parents=0 HEAD | head -1)
            echo "‚úÖ First release detected, using initial commit: $base_sha"
            echo "‚ÑπÔ∏è  Note: If this is not the first release, tracking file is missing - consider manual recovery"
          fi
          
          # Final validation
          if ! git rev-parse --verify "$base_sha" >/dev/null 2>&1; then
            echo "‚ùå Final base SHA is invalid: $base_sha"
            exit 1
          fi
          
          echo "base_sha=$base_sha" >> $GITHUB_OUTPUT
        shell: bash

      - name: Detect new policy versions
        id: detect
        uses: ./.github/actions/detect-versions
        with:
          base-sha: ${{ steps.get_base.outputs.base_sha }}
          head-sha: ${{ github.sha }}

      - name: Format versions for matrix
        id: format
        run: |
          versions="${{ steps.detect.outputs.new-versions }}"
          json_array="[]"
          if [ -n "$versions" ]; then
            json_array="["
            first=true
            for version_path in $versions; do
              if [ "$first" = true ]; then
                first=false
              else
                json_array+=","
              fi
              policy=$(echo $version_path | cut -d'/' -f1)
              version=$(echo $version_path | cut -d'/' -f2)
              json_array+="{\"policy\":\"$policy\",\"version\":\"$version\"}"
            done
            json_array+="]"
          fi
          echo "json=$json_array" >> $GITHUB_OUTPUT

      - name: Count versions
        id: count
        run: |
          version_count=$(echo "${{ steps.detect.outputs.new-versions }}" | wc -w)
          echo "count=$version_count" >> $GITHUB_OUTPUT

  validate-policies:
    name: Validate Policies
    needs: detect-versions
    if: needs.detect-versions.outputs.version-count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate policies before release
        run: |
          echo "üîç Validating all policies before release using configurable requirements..."
          
          # Make validation script executable
          chmod +x scripts/validate-policy.sh
          
          validation_errors=0
          versions="${{ needs.detect-versions.outputs.new-versions }}"
          
          for version_path in $versions; do
            policy=$(echo $version_path | cut -d'/' -f1)
            version=$(echo $version_path | cut -d'/' -f2)
            
            echo "üìã Pre-release validation for $policy/$version"
            
            if ./scripts/validate-policy.sh "$policy" "$version" 2>&1; then
              echo "‚úÖ Pre-release validation passed for $policy/$version"
            else
              echo "‚ùå Pre-release validation failed for $policy/$version"
              ((validation_errors++))
            fi
          done
          
          if [ $validation_errors -gt 0 ]; then
            echo ""
            echo "üí• Pre-release validation failed with $validation_errors error(s)."
            echo "üìã Release blocked - fix validation issues before publishing"
            exit 1
          else
            echo ""
            echo "üéâ All policies passed pre-release validation!"
            echo "üìã Ready for publishing with configurable requirements verified"
          fi

  publish-policies:
    name: Publish to Production
    needs: [detect-versions, validate-policies]
    if: needs.detect-versions.outputs.version-count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 30
    environment: production
    continue-on-error: true
    strategy:
      fail-fast: false
      matrix:
        version-item: ${{ fromJSON(needs.detect-versions.outputs.new-versions-json) }}
      max-parallel: ${{ vars.MAX_PARALLEL || 3 }}
    outputs:
      job-status: ${{ steps.final-status.outputs.status }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Publish policy version
        id: publish
        uses: ./.github/actions/publish-policy
        with:
          policy: ${{ matrix.version-item.policy }}
          version: ${{ matrix.version-item.version }}
          release-tag: ${{ github.event.release.tag_name }}
          s3-bucket: ${{ vars.S3_BUCKET_NAME }}
          policy-hub-url: ${{ vars.POLICY_HUB_API_URL }}
          repo-url: ${{ github.server_url }}/${{ github.repository }}
          policy-hub-api-key: ${{ secrets.POLICY_HUB_API_KEY }}

      - name: Report result
        if: always()
        run: |
          if [[ "${{ steps.publish.outputs.success }}" == "true" ]]; then
            echo "‚úÖ Successfully published ${{ matrix.version-item.policy }} ${{ matrix.version-item.version }}"
          else
            echo "‚ùå Failed to publish ${{ matrix.version-item.policy }} ${{ matrix.version-item.version }}"
            echo "‚ö†Ô∏è  This failure will be tracked - failed policies will be retried in next release"
            exit 1
          fi
      
      - name: Set final status
        id: final-status
        if: always()
        run: |
          if [[ "${{ steps.publish.outputs.success }}" == "true" ]]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

  check-publish-results:
    name: Check Publishing Results
    needs: [detect-versions, publish-policies]
    if: always() && needs.detect-versions.outputs.version-count > 0
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      all-succeeded: ${{ steps.check.outputs.all_succeeded }}
    steps:
      - name: Check if all policies published successfully
        id: check
        run: |
          # Note: With continue-on-error, we need to check job conclusion
          # If any matrix job failed, the overall job shows as success but with failures
          publish_result="${{ needs.publish-policies.result }}"
          
          if [[ "$publish_result" == "success" ]]; then
            echo "all_succeeded=true" >> $GITHUB_OUTPUT
            echo "‚úÖ All policies published successfully"
          else
            echo "all_succeeded=false" >> $GITHUB_OUTPUT
            echo "‚ùå Some policies failed to publish"
            echo "‚ö†Ô∏è  Failed policies will be retried in next release"
          fi

  update-success-sha:
    name: Update Success Tracking
    needs: [detect-versions, validate-policies, publish-policies, check-publish-results]
    if: always() && (needs.detect-versions.result == 'success') && (needs.validate-policies.result == 'success' || needs.validate-policies.result == 'skipped') && (needs.check-publish-results.outputs.all-succeeded == 'true' || needs.publish-policies.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Update last successful release SHA
        run: |
          set -euo pipefail
          
          current_sha="${{ github.sha }}"
          file="last-successful-release.sha"
          
          # Check if update is needed
          if [ -f "$file" ] && [ "$(cat $file | tr -d '\n')" = "$current_sha" ]; then
            echo "‚ÑπÔ∏è  SHA file already up-to-date, skipping update"
            exit 0
          fi
          
          # Update the file
          echo "$current_sha" > "$file"
          # Generate checksum for integrity
          echo "$current_sha" | sha256sum | awk '{print $1}' > "${file}.sha256"
          
          # Configure Git
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add and commit
          git add "$file" "${file}.sha256"
          git commit -m "chore: update last successful release SHA to $current_sha"
          
          # Push with retry
          max_retries=3
          retry_count=0
          while [ $retry_count -lt $max_retries ]; do
            if git push origin HEAD:main 2>&1; then
              echo "‚úÖ Successfully updated last successful release SHA"
              exit 0
            else
              retry_count=$((retry_count + 1))
              echo "‚ö†Ô∏è  Push failed (attempt $retry_count/$max_retries), retrying in 5s..."
              sleep 5
            fi
          done
          
          echo "‚ùå Failed to push SHA update after $max_retries attempts"
          echo "‚ö†Ô∏è  WARNING: Release was successful but tracking file not updated"
          echo "‚ö†Ô∏è  Next release may re-process some policies"
          echo "‚ö†Ô∏è  Recommend: Manually commit tracking file or investigate git push failure"
          exit 1
        shell: bash